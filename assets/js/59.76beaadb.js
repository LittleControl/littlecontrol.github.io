(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{409:function(v,_,e){"use strict";e.r(_);var o=e(25),d=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"js正则中关于-n问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js正则中关于-n问题"}},[v._v("#")]),v._v(" JS正则中关于"),e("code",[v._v("\\n")]),v._v("问题")]),v._v(" "),e("p",[v._v("今天遇到了一个正则表达式"),e("code",[v._v("/(\\d)\\1*/")]),v._v(",这时候就有点蒙蔽的是这个"),e("code",[v._v("\\1")]),v._v("是什么意思.如果是要单独匹配1这个数字的话,只写一个1就好了,为什么还要加一个"),e("code",[v._v("\\")]),v._v("的.后来百度Google啥的都是说的"),e("code",[v._v("\\n")]),v._v("匹配的换行符.是,没错.但是我的这个n是一个数字变量,不是一个固定值.后来在MDN上看到了相关的解释,解释如下"),e("code",[v._v("在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)")]),v._v(".看完之后还是一头雾水,到底啥意思.知道我Google的一个评论,才恍然大悟."),e("br"),v._v("\n原来这个就是正则表达式中的反向引用.用"),e("code",[v._v("\\n")]),v._v("指代前几个捕获分组的内容."),e("code",[v._v("\\1")]),v._v("就是第一个捕获分组,"),e("code",[v._v("\\2")]),v._v("就是第二个捕获分组."),e("br"),v._v("\n直观的看,"),e("code",[v._v("/(\\d)\\1*/")]),v._v(",这里的"),e("code",[v._v("\\1")]),v._v("就代表了前面第一个捕获分组(括号的内的)"),e("code",[v._v("\\d")]),v._v("所匹配到的内容.如果前面"),e("code",[v._v("\\d")]),v._v("匹配到的是9,那么这个"),e("code",[v._v("\\1")]),v._v("就是9,匹配到1,这个"),e("code",[v._v("\\1")]),v._v("就是1."),e("br"),v._v("\n这时候有人就要问了,那我直接"),e("code",[v._v("/(\\d)(\\d)*/")]),v._v("这样不可以吗.那肯定不行呀,你想,如果这个是匹配两个数字,匹配到的这个数字相同不相同都可以.但是"),e("code",[v._v("/(\\d)\\1*/")]),v._v("而这如果要匹配两个数字的话,那么这两个数字一定是相同的,因为"),e("code",[v._v("\\1")]),v._v("就是代表了上一个"),e("code",[v._v("\\d")]),v._v("的匹配结果.将正则的匹配结果应用到匹配模式上,这就是为什么叫做反向引用的原因.")])])}),[],!1,null,null,null);_.default=d.exports}}]);