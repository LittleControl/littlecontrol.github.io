(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{411:function(e,t,r){"use strict";r.r(t);var s=r(42),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"script标签中的defer和async属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#script标签中的defer和async属性"}},[e._v("#")]),e._v(" script标签中的defer和async属性")]),e._v(" "),r("h2",{attrs:{id:"async"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[e._v("#")]),e._v(" async")]),e._v(" "),r("ul",[r("li",[r("code",[e._v('<script src="index.js" async><\/script>')])]),e._v(" "),r("li",[e._v("设有"),r("code",[e._v("async")]),e._v("属性的脚本不会打断HTML文档的解析,但是一旦加载完毕就会立即执行——无论此刻是HTML解析阶段还是 "),r("code",[e._v("DOMContentLoaded")]),e._v("触发之后.")]),e._v(" "),r("li",[e._v("需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行.")]),e._v(" "),r("li",[e._v("需要注意的是,async脚本的执行顺序是不确定的.")]),e._v(" "),r("li",[e._v("async适用于普通脚本和模块脚本,不适用于内嵌脚本")])]),e._v(" "),r("h2",{attrs:{id:"defer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[e._v("#")]),e._v(" defer")]),e._v(" "),r("ul",[r("li",[r("code",[e._v('<script src="index.js" defer><\/script>')])]),e._v(" "),r("li",[e._v("设有"),r("code",[e._v("defer")]),e._v("属性的脚本也不会打断HTML文档的解析,与async不同的是,defer脚本即使已经加载完毕也不会立即执行,而是一定会在HTML文档解析完毕的时候执行.")]),e._v(" "),r("li",[e._v("也就是在"),r("code",[e._v("DOMContentLoaded")]),e._v("会执行所有由 defer-script 加载的 JavaScript 代码")]),e._v(" "),r("li",[e._v("需要注意的是,defer不会改变代码的执行顺序")]),e._v(" "),r("li",[e._v("defer只适用于普通脚本,不适用于模块脚本和内嵌脚本,(模块脚本默认defer)")])])])}),[],!1,null,null,null);t.default=a.exports}}]);